use crate::webrtc::ice_transport::ice_server::RTCIceServer;
use crate::webrtc::peer_connection::certificate::RTCCertificate;
use crate::webrtc::peer_connection::policy::ice_transport_policy::RTCIceTransportPolicy;
use crate::webrtc::peer_connection::policy::sdp_semantics::RTCSdpSemantics;

/// A Configuration defines how peer-to-peer communication via PeerConnection
/// is established or re-established.
/// Configurations may be set up once and reused across multiple connections.
/// Configurations are treated as readonly. As long as they are unmodified,
/// they are safe for concurrent use.
#[derive(Default)]
pub(crate) struct RTCConfiguration {
    /// iceservers defines a slice describing servers available to be used by
    /// ICE, such as STUN and TURN servers.
    pub(crate) ice_servers: Vec<RTCIceServer>,

    /// icetransport_policy indicates which candidates the ICEAgent is allowed
    /// to use.
    pub(crate) ice_transport_policy: RTCIceTransportPolicy,

    /// Certificates describes a set of certificates that the PeerConnection
    /// uses to authenticate. Valid values for this parameter are created
    /// through calls to the generate_certificate function. Although any given
    /// DTLS connection will use only one certificate, this attribute allows the
    /// caller to provide multiple certificates that support different
    /// algorithms. The final certificate will be selected based on the DTLS
    /// handshake, which establishes which certificates are allowed. The
    /// PeerConnection implementation selects which of the certificates is
    /// used for a given connection; how certificates are selected is outside
    /// the scope of this specification. If this value is absent, then a default
    /// set of certificates is generated for each PeerConnection instance.
    pub(crate) certificates: Vec<RTCCertificate>,

    /// sdp_semantics controls the type of SDP offers accepted by and
    /// SDP answers generated by the PeerConnection.
    pub(crate) sdp_semantics: RTCSdpSemantics,
}

impl RTCConfiguration {
    /// get_iceservers side-steps the strict parsing mode of the ice package
    /// (as defined in https://tools.ietf.org/html/rfc7064) by copying and then
    /// stripping any erroneous queries from "stun(s):" URLs before parsing.
    pub(crate) fn get_ice_servers(&self) -> Vec<RTCIceServer> {
        let mut ice_servers = self.ice_servers.clone();

        for ice_server in &mut ice_servers {
            for raw_url in &mut ice_server.urls {
                if raw_url.starts_with("stun") {
                    // strip the query from "stun(s):" if present
                    let parts: Vec<&str> = raw_url.split('?').collect();
                    *raw_url = parts[0].to_owned();
                }
            }
        }

        ice_servers
    }
}